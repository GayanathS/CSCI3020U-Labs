(+ 1 3)
#"\$\d+"
(def pat #"\$\d+")
pat
"Today i made $40, and yesterday I made $58.30"
(re-seq pat "Today i made $40, and yesterday i made $58.30")
(re-seq #"\$\d+", "Today i made $40, and yesterday i mande $58.30")
(reduce + 0 (7 3 1 5))
(reduce +0 (7 3 1 5))
(reduce + 0 '(7 3 1 5))
(def divisable-by-3 (fn [n] (zero? (rem n 3)))
(divisable-by-3 11)
(def divisable-by-3 (fn [n] (zer0? (rem n 3)))
(take 100 nat)
(def nat (iterate 100))
(def nat (iterate inc 0))
(defn even? [n] (zero? (mod n 2)))
(defn even-nat (filter even? nat))
(take even-nat)
(defn even-nat(filter even? nat))
 (defn even? [n] (zero? (mod n 2)))
(defn even-nat (filter even? nat))
(defn odd-nat (filter #(not (even? %1))nat))
clscr
(f 10)
(doc cons)
clsc
cls
clscr
(cons 100 [1 2 3])
(cons (f 1)(cons (f 2)(cons(f 3)null))
(cons (f 1) (cons (f 2) (cons(f 3)null ))
(defn fs [n]
  (if (zero? n)
    nil
    (lazy-seq (cons (f n) (fs (dec n))))))
[(f 1) (f 2) (f 3)]
(defn f [x]
  (do (println "zzz..." x)
      (Thread/sleep 1500)
      (str "a long sleep (" x ")")))
[(f 1) (f 2) (f 3)]
(defn fs [n]
  (if (zero? n)
    nil
    (lazy-seq (cons (f n) (fs (dec n))))))
(take 3 (fs 1000))
f
(def input [:a 1 :b 2 :c 3)
(def input [:a 1 :b 2 :c 3])
(let [n (count input) indexes (range n)] indexes)
(let [n (count input) indexes (range n)] (map vector indexes input))
(let [n (count input) indexes (range n)](filter # (even? (nth % 0)) (map vector indexes input)))
(let [n count input)
gedit
